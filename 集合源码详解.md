# 集合源码详解

# 一、常见数据结构讲解

## 1. 线性数据结构

&emsp;&emsp;线性表:顾名思义，线性表就是数据排成像一条线的结构。每个线性表上的数据最多只有前和后两个方向。线性表结构：数组、链表、队列、栈

### 1.1 数组

&emsp;&emsp;数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

```java
// 动态初始化：初始化时由程序员只指定数组长度，由系统为数组元素分配初始值
char c1[] = new char[5];
// 静态初始化： 初始化时由程序员显示置顶每个数组的初始值，由系统决定数组长度
char c2[] = new char[]{'E','D','U','Y','U'};
char c3[] = {'E','D','U','Y','U'};
```

具有如下的特点：

* 内存地址连续，
* 可以通过下标的成员访问,下标访问的性能高
* 增删操作带来更大的性能消耗(保证数据越界的问题,需动态扩容)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/2fab3d1d779a4704b0ac1f9a9e428334.png)

### 1.2 队列

&emsp;&emsp;队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
&emsp;&emsp;队列中数据的特点：先进先出，后进后出。

**队列的操作**：允许插入的一端称为队尾，允许删除的一端称为队头。我们可以将其想象成一个链表，队头就是这个链表中的第一个节点，队尾就是这个链表中的最后一个节点，然而我们只能对这个链表进行 尾插、头删操作。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/df6584d4036c450699619dbbcc63a651.png)

数据结构演示地址：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

入队列

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/fb2ec315b66a44c9817d2e9f5c3b4ff2.png)

出队列

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/d734e4d156604e81a4de73d9e7f9f96a.png)

Java代码测试实现

```java
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(3);//尾插
        queue.offer(6);
        queue.offer(9);
        queue.offer(12);
        System.out.println(queue);
        System.out.println(queue.peek());//访问队列头元素
        System.out.println(queue);
        System.out.println(queue.poll());//删除队列头元素
        System.out.println(queue);
    }
```

输出结果：

```txt
[3, 6, 9, 12]
3
[3, 6, 9, 12]
3
[6, 9, 12]
```

### 1.3 链表

&emsp;&emsp;链表也是线性的顺序存储数据。只是在内存地址上不是连续的，每一个节点里存到下一个节点的指针(Pointer).

#### 1.3.1 单向链表

&emsp;&emsp;单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针，下图就是一个单链表，表头为空，表头的后继节点是"结点10"(数据为10的结点)，“节点10"的后继结点是"节点20”(数据为10的结点)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/093f497d02594f1bb125b0aa7b190c89.png)

&emsp;&emsp;然后我们来看下删除链表的操作，比如删除30这个节点

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/1c7291f1247d4eb9a940fb6e86a81601.png)

&emsp;&emsp;在上面的结构基础上我们再来添加一个节点到链表中

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/89f1f62cc2644e76b4b2cad5d615ea09.png)

#### 1.3.2 双向链表

&emsp;&emsp;双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。

  双链表的示意图如下：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/cbc1f385cbc44a649b6fc9512e3024b6.png)

双向链表的具体实现可以参考:

```java
    static final class Node {
       // 前一个节点
        volatile Node prev;
        // 后一个节点
        volatile Node next;
		// 链表节点存储的具体数据
        volatile Thread thread;
    }
```

我们看看双向链表删除节点的操作，比如说下面这个单链表中我们要删除"节点30"。

**删除之前**：“节点20"的后继节点为"节点30”，“节点30” 的前继节点为"节点20"。“节点30"的后继节点为"节点40”，“节点40” 的前继节点为"节点30"。

**删除之后**：“节点20"的后继节点为"节点40”，“节点40” 的前继节点为"节点20"。![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/6095a19ab0774a98ac40a46ce68063b3.png)

我们再来看看双向链表添加节点的操作，比如说下面这个双向链表在"节点10"与"节点20"之间添加"节点15"

**添加之前**：“节点10"的后继节点为"节点20”，“节点20” 的前继节点为"节点10"。

**添加之后**：“节点10"的后继节点为"节点15”，“节点15” 的前继节点为"节点10"。“节点15"的后继节点为"节点20”，“节点20” 的前继节点为"节点15"。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/16d355d46a0d41ce8d672c484e7501ae.png)

### 1.4 栈

&emsp;&emsp;**栈**(stack)是限定仅在表尾进行插入或者删除的线性表。对于栈来说，表尾端称为栈顶（top），表头端称为栈低（bottom）。不含元素的空表称为空栈。因为栈限定在表尾进行插入或者删除，所以栈又被称为后进先出的线性表（简称LIFO:Last in, First out.结构）。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/68ec38a0a208450887025531792a4615.png)

## 2. 非线性数据结构

&emsp;&emsp;非线性表:与线性表对立，在非线性表之中，数据之间并不是简单的前后关系。非线性表结构：二叉树、堆、图等。

### 2.1 树

&emsp;&emsp;树[Tree]是n（n>=0)个结点的有限集。n=0时称为空树。在任意一颗非空树中：

1. 有且仅有一个特定的称为根[Root]的结点；
2. 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、…、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。

&emsp;&emsp;此外，树的定义还需要强调以下两点：

1. 根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。
2. 子树的个数没有限制，但它们一定是互不相交的。

如图，是一棵普通树

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/2ec98614a034488f95724bbf6b5df616.png)

度数：结点拥有的子树数目称为结点的 **度** 。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/083d59f3986e4869a85ad8b0ccdc98f4.png)

节点关系：

* 孩子结点
* 双亲结点
* 兄弟结点

节点层次：

&emsp;&emsp;从根开始定义起，根为第一层，根的孩子为第二层，以此类推。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/b7923f7ef5f34b98896cef6112781c17.png)

树的深度：树中结点的最大层次，如上图深度为4

### 2.2 二叉树

#### 2.2.1 概念介绍

**&emsp;&emsp;二叉树** ：每个子节点只有两个节点的树，每个结点至多拥有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/2c3799646cf54453afc9e0a144830d3d.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/82231a46d32a4ffe80deb8b6fbded2a2.png)

**二叉查找树**也称为有序二叉查找树,满足二叉查找树的一般性质,是指一棵空树具有如下性质：

1. 任意节点左子树不为空,则左子树的值均小于根节点的值
2. 任意节点右子树不为空,则右子树的值均大于于根节点的值
3. 任意节点的左右子树也分别是二叉查找树
4. 没有键值相等的节点

二叉树又分为：

* 完美二叉树
* 完全二叉树
* 完满二叉树

完美二叉树：又称为 **满二叉树** ，除了叶子节点之外的每一个节点都有两个孩子节点，每层都被完全填充

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/14cfd7290c6d461fa446542d98612211.png)

完全二叉树:除了最后一层之外的其他每一层都被完全填充，并且所有的节点都保持向左对齐

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/06417f0102a548dd80655648bbb59f6d.png)

完满二叉树：除了叶子节点之外的每一个节点都有两个孩子节点。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/ffc32e5dd4004b9e91835dbe90a1d90d.png)

#### 2.2.2 遍历操作

二叉树中的遍历规则有如下三种：

中序遍历：所谓的中序遍历就是先访问左节点，再访问根节点，最后访问右节点，即左-根-右遍历

先序遍历：所谓的前序遍历就是先访问根节点，再访问左节点，最后访问右节点，即根-左-右遍历(前序)

后序遍历：所谓的后序遍历就是先访问左节点，再访问右节点，最后访问根节点。即左-右-根遍历![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/0da39a40def74185b5939df006aeb4d2.png)

查找最小值：沿着根节点的左子树一路查找，直到最后一个不为空的节点，该节点就是当前这个树的最小节点

查找最大值：沿着根节点的右子树一路查找，直到最后一个不为空的节点，该节点就是当前这个树的最大节点

**查找前驱节点** ：小于当前节点的最大值

**查找后继节点** ：大于当前节点的最小值

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/ce6fb65a0a674dbba38c0fa7782aa505.png)

#### 2.2.3 删除节点

&emsp;&emsp;二叉树中的删除节点：本质上是找前驱节点或者后继节点来替代

* 叶子节点直接删除
* 只有一个子节点的用子节点替代(本质上就是找的前驱节点或者后继节点，左节点就是前驱节点，右节点就是后继节点)
* 有两个子节点的，需要找到替代节点(替代节点就是前驱节点或者后继节点)

#### 2.2.4 查找局限性

&emsp;&emsp;一个二叉查找树是由n个节点随机构成,所以，对于某些情况,二叉查找树会退化成一个有n个节点的线性链.如下图:

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/e14021fc8441414eaaac8f55add84387.png)

#### 2.2.5 AVL

  BST存在的问题是，树在插入的时候会导致倾斜，不同的插入顺序会导致数的高度不一样，而树的高度直接影响了树的查找效率。最坏的情况所有的节点都在一条斜线上，这样树的高度为N。基于BST存在的问题，平衡查找二叉树（Balanced BST）产生了。平衡树的插入和删除的时候，会通过旋转操作将高度保持在LogN。其中两款具有代表性的平衡术分别为AVL树（高度平衡树，具备二叉搜索树的全部特性，而且左右子树高度差不超过1）和红黑树。

  AVL树是如何实现平衡的呢？，具体是通过左旋或者右旋来实现的。具体如下图：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/6c1eab108270443893b76a406e8f56ee.png)

&emsp;&emsp;虽然AVL可以解决二叉树所存在的问题，但是AVL树要求太过严格，左旋和右旋的开销会比较大，这时出现了红黑树，只要求黑色节点平衡即可.

### 2.3 2-3-4树

#### 1  概念介绍

&emsp;&emsp;2-3-4树是四阶的 B树(Balance Tree)，他属于一种多路查找树，它的结构有以下限制：
&emsp;&emsp;所有叶子节点都拥有相同的深度。
&emsp;&emsp;节点只能是 2-节点、3-节点、4-节点之一。

- 2-节点：包含 1 个元素的节点，有 2 个子节点；
- 3-节点：包含 2 个元素的节点，有 3 个子节点；
- 4-节点：包含 3 个元素的节点，有 4 个子节点；

所有节点必须至少包含1个元素
元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点；
而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。

下图是一个典型的 2-3-4树
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223323277.png)

#### 2 生成的过程

&emsp;&emsp;接下来我们通过演示来看看2-3-4树生成的过程
第一次插入---2节点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223353279.png)

插入第二个节点--3节点 合并
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223404241.png)

插入第三个节点---4节点 合并
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223414953.png)

插入第4个节点---需要分裂
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223426328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

插入6
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223436363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
插入7
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223447432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

插入8
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223457158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
插入9
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223508210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

插入10
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021061422351969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
插入11
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223528968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

插入12
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223538594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
最后我们插入1来看看效果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223548372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

&emsp;&emsp;到这儿相信大家对于2-3-4树应该有了个直观的认知了。

#### 3 和红黑树的等价关系

&emsp;&emsp;红黑树起源于2-3-4树，它的本质就是2-3-4树。

##### 3.1 2节点

```

```

&emsp;&emsp;一个2节点对应的红黑树节点就是一个黑色节点

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223653661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

##### 3.2 3节点

&emsp;&emsp;一个三节点可以有两种情况的红黑树节点，一种是右倾，一种是左倾，所以一个2-3-4树可以有多个红黑树
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223714217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

原则：上黑下红

##### 3.3 4节点

&emsp;&emsp;一个四节点转换的情况只有一种，中间节点黑色，左右节点红色
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223742830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

##### 3.4 裂变状态

&emsp;&emsp;还有就是在2-3-4树中存在的裂变状态。转换为红黑树后会先变色(不能有两个相邻的红色节点)。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223756716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

#### 4 转换为红黑树

&emsp;&emsp;接下来具体看看一个2-3-4树是如何转换为对应的红黑树的，

原始的2-3-4树：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223821133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

&emsp;&emsp;按照右倾规则来转换为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223830756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
&emsp;&emsp;转换后满足黑色节点平衡的要求
&emsp;&emsp;按照左倾规则来转换为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614223844987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

### 2.4 红黑树

&emsp;&emsp;红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:

1. 每个节点要么是黑色，要么是红色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。
4. 每个红色结点的两个子结点一定都是黑色。
5. 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。

&emsp;&emsp;红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色

| 操作 | 描述                                                                                                                            |
| ---- | ------------------------------------------------------------------------------------------------------------------------------- |
| 左旋 | 以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，<br>右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。  |
| 右旋 | 以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，<br/>左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。 |
| 变色 | 结点的颜色由红变黑或由黑变红。                                                                                                  |

#### 1 旋转操作

##### 1.1 概念讲解

&emsp;&emsp;**左旋**：以某个节点作为旋转点，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101118357.gif)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101134656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

&emsp;&emsp;**右旋**：以某!个节点作为旋转点，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101152636.gif)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101204456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

##### 1.2 代码实现

&emsp;&emsp;先进行类结构定义

```java
package com.bobo.util.treemap;

public class BRTree {

    private static final boolean RED = false;
    private static final boolean BLACK = true;

    private RBNode root;

    public RBNode getRoot() {
        return root;
    }

    public void setRoot(RBNode root) {
        this.root = root;
    }


    /**
     * 表示 节点
     * @param <K>
     * @param <V>
     */
    static class RBNode<K extends Comparable<K>,V>{
        // 节点是双向的
        private RBNode parent;
        private RBNode left;
        private RBNode right;
        private boolean color;
        private K key;
        private V value;

        public RBNode() {
        }

        public RBNode(RBNode parent, RBNode left, RBNode right, boolean color, K key, V value) {
            this.parent = parent;
            this.left = left;
            this.right = right;
            this.color = color;
            this.key = key;
            this.value = value;
        }

        public RBNode getParent() {
            return parent;
        }

        public void setParent(RBNode parent) {
            this.parent = parent;
        }

        public RBNode getLeft() {
            return left;
        }

        public void setLeft(RBNode left) {
            this.left = left;
        }

        public RBNode getRight() {
            return right;
        }

        public void setRight(RBNode right) {
            this.right = right;
        }

        public boolean isColor() {
            return color;
        }

        public void setColor(boolean color) {
            this.color = color;
        }

        public K getKey() {
            return key;
        }

        public void setKey(K key) {
            this.key = key;
        }

        public V getValue() {
            return value;
        }

        public void setValue(V value) {
            this.value = value;
        }
    }
}

```

左旋代码实现

```java
    /**
     * 围绕p左旋
     *     p               pr(r)
     *    / |             / \
     *   pl  pr(r) =>    p   rr
     *      / \         / \
     *     rl  rr     pl  rl
     *
     *  左旋的时候
     *  p-pl 和 pr-rr的关系不变
     *  pr-rl 要变为 p-rl
     *      也就是 rl要变为 p的右子节点
     *      同时 p要成为 rl 的父节点
     *  还有就是要判断  p 是否有父节点
     *  如果没有
     *     r 变为 root 节点
     *  如果有
     *     r.parent = p.parent
     *     还要设置 r为 p.parent 的子节点(可能左也可能右)
     *     如果 p.parent.left == p
     *        p.parent.left = r;
     *     否则
     *        p.parent.right = r;
     *    最后
     *       p.parent = r;
     *       r.left = p;
     * @param p
     */
    private void leftRotate(RBNode p){
        if(p != null){
            RBNode r = p.right;
            // 1.设置 pr-rl 要变为 p-rl
            // 把rl设置到p的右子节点
            p.right = r.left;
            if(r.left != null){
                // 设置rl的父节点为p
                r.left.parent = p;
            }
            // 2.判断p的父节点情况
            r.parent = p.parent; // 不管 p是否有父节点，都把这个父节点设置为 r的父节点
            if(p.parent == null){
                root = r; // p没有父节点 则r为root节点
            }else if(p.parent.left == p){
                p.parent.left = r; // 如果p为 p.parent的左子节点 则 r 也为 p.parent的左子节点
            }else{
                p.parent.right = r; // 反之设置 r 为 p.parent的右子节点
            }
            // 最后 设置 p 为 r 的左子节点
            r.left = p;
            p.parent = r;
        }
    }
```

右旋实现：

```java
    /**
     * 围绕p右旋
     * @param p
     */
    public void rightRotate(RBNode p){
        if(p != null){
            RBNode r = p.left;
            p.left = r.right;
            if(r.right != null){
                r.right.parent = p;
            }
            r.parent = p.parent;
            if(p.parent == null){
                root = r;
            }else if(p.parent.left == p){
                p.parent.left = r;
            }else{
                p.parent.right = r;
            }
            r.right = p;
            p.parent = r;
        }
    }
```

#### 2 新增节点

&emsp;&emsp;https://www.processon.com/view/link/60c21e25e401fd34a1514d25

&emsp;&emsp;2-3-4树中结点添加需要遵守以下规则：

- 插入都是向最下面一层插入
- 升元：将插入结点由 2-结点升级成 3-结点，或由 3-结点升级成 4-结点；
- 向 4-结点插入元素后，需要将中间元素提到父结点升元，原结点变成两个 2-结点，再把元素插入2-结点中，如果父结点也是 4-结点，则递归向上层升元，至到根结点后将树高加1；

&emsp;&emsp;而将这些规则对应到红黑树里，就是：

- 新插入的结点颜色为 红色 ，这样才可能不会对红黑树的高度产生影响。
- 2-结点对应红黑树中的单个黑色结点，插入时直接成功（对应 2-结点升元）。
- 3-结点对应红黑树中的 黑+红 子树，插入后将其修复成 红+黑+红 子树（对应 3-结点升元）；
- 4-结点对应红黑树中的 红+黑+红 子树，插入后将其修复成 红色祖父+黑色父叔+红色孩子 子树，然后再把祖父结点当成新插入的红色结点递归向上层修复，直至修复成功或遇到 root 结点；

&emsp;&emsp;公式：**红黑树**+新增一个节点（红色）**=**对等的2-3-4树+新增一个节点

##### 2.1 新增节点示例

&emsp;&emsp;我们通过新增2-3-4树的过程来映射对应的红黑树的节点新增
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101303536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

**2-3-4树的新增（全部在叶子节点完成）**

**1.新增一个节点，2 节点**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101319193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

**2.新增一个节点，与2节点合并，直接合并**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101332737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
**3.新增一个节点，与3节点合并，直接合并**

插入的值的位置会有3种情况![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101345221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

对应的红黑树为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101357630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

**4.新增一个节点，与4节点合并，此时需要分裂**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101409855.png)

**插入值的位置可能是**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101419959.png)

对应的红黑树的结构为
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101429815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

##### 2.2 新增代码实现

&emsp;&emsp;红黑树的新增规则我们理清楚了，接下来就可以通过Java代码来具体的实现了。

先实现插入节点，这就是一个普通的二叉树的插入

```java
 /**
     * 新增节点
     * @param key
     * @param value
     */
    public void put(K key , V value){
        RBNode t = this.root;
        if(t == null){
            // 说明之前没有元素，现在插入的元素是第一个
            root = new RBNode<>(key , value == null ? key : value,null);
            return ;
        }
        int cmp ;
        // 寻找插入位置
        // 定义一个双亲指针
        RBNode parent;
        if(key == null){
            throw new NullPointerException();
        }
        // 沿着跟节点找插入位置
        do{
            parent = t;
            cmp = key.compareTo((K)t.key);
            if(cmp < 0){
                // 左侧找
                t = t.left;
            }else if(cmp > 0){
                // 右侧找
                t = t.right;
            }else{
                // 插入节点的值==比较的节点。值替换
                t.setValue(value==null?key:value);
                return;
            }
        }while (t != null);
        // 找到了插入的位置  parent指向 t 的父节点  t为null
        // 创建要插入的节点
        RBNode<K, Object> e = new RBNode<>(key, value == null ? key : value, parent);
        // 然后判断要插入的位置 是 parent的 左侧还是右侧
        if(cmp < 0){
            parent.left = e;
        }else{
            parent.right = e;
        }
        // 调整  变色 旋转
        fixAfterPut(e);
    }
```

然后再根据红黑树的特点来实现调整(旋转，变色)

```java
private boolean colorOf(RBNode node){
        return node == null ? BLACK:node.color;
    }

    private RBNode parentOf(RBNode node){
        return node != null ? node.parent:null;
    }

    private RBNode leftOf(RBNode node){
        return node != null ? node.left:null;
    }

    private RBNode rightOf(RBNode node){
        return node != null ? node.right:null;
    }

    private void setColor(RBNode node ,boolean color){
        if(node != null){
            node.setColor(color);
        }
    }

    /**
     * 插入节点后的调整处理
     * 1. 2-3-4树 新增元素 2节点添加一个元素将变为3节点 直接合并，节点中有两个元素
     *      红黑树：新增一个红色节点，这个红色节点会添加在黑色节点下(2节点) --- 这种情况不需要调整
     * 2. 2-3-4树 新增元素 3节点添加一个元素变为4节点合并 节点中有3个元素
     *      这里有6中情况，( 根左左 根左右  根右右 根右左)这四种要调整  (左中右的两种)不需要调整
     *      红黑树：新增红色节点 会添加到 上黑下红的节点中 = 排序后中间节点是黑色，两边节点是红色
     *
     *  3. 2-3-4树：新增一个元素 4节点添加一个元素需要裂变：中间元素升级为父节点，新增元素与剩下的其中一个合并
     *      红黑树：新增节点是红色+爷爷节点是黑色，父亲节点和叔叔节点为红色 调整为
     *              爷爷节点变红色，父亲和叔叔节点变为黑色，如果爷爷节点为root节点则调整为黑色
     * @param x
     */
    private void fixAfterPut(RBNode<K, Object> x) {
        x.color = RED;
        // 本质上就是父节点是黑色的就不需要调整，对应的 2 3的情况
        while(x != null && x != root && x.parent.color == RED){
            // 1. x 的父节点是爷爷的 左孩子
            if(parentOf(x) == parentOf(parentOf(x)).left){
                // 获取当前节点的叔叔节点
                RBNode y = rightOf(parentOf(parentOf(x)));
                // 情况3
                if(colorOf(y) == RED){
                    // 说明是 上3的情况  变色处理
                    // 父亲节点和叔叔节点设置为黑色
                    setColor(parentOf(x),BLACK);
                    setColor(y,BLACK);
                    // 爷爷节点设置为 红色
                    setColor(parentOf(parentOf(x)),RED);
                    // 递归处理
                    x = parentOf(parentOf(x));
                }else{
                    // 情况 2
                    if(x == parentOf(x).right){
                        // 如果x是父节点的右节点那么我们需要先根据 父节点 左旋
                        x = parentOf(x);
                        leftRotate(x);
                    }
                    // 叔叔节点为空  对应于 上面的情况2
                    // 将父节点变为黑色
                    setColor(parentOf(x),BLACK);
                    // 将爷爷节点变为红色
                    setColor(parentOf(parentOf(x)),RED);
                    // 右旋转  根据爷爷节点右旋转
                    rightRotate(parentOf(parentOf(x)));

                }
            }else{
                // x 的父节点是爷爷是右孩子
                // 获取父亲的叔叔节点
                RBNode y = leftOf(parentOf(parentOf(x)));
                if(colorOf(y) == RED){
                    // 情况3
                    setColor(parentOf(x),BLACK);
                    setColor(y,BLACK);
                    setColor(parentOf(parentOf(x)),RED);
                    x = parentOf(parentOf(x));
                }else{
                    // 情况2
                    if( x == parentOf(x).left){
                        x = parentOf(x);
                        rightRotate(x);
                    }
                    setColor(parentOf(x),BLACK);
                    setColor(parentOf(parentOf(x)),RED);
                    leftRotate(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }
```

##### 2.3 插入节点

&emsp;&emsp;不通过2-3-4树来实现添加节点的分析，看大家是否能理解哦
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101529908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
插入的场景
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101541938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

**插入场景1**：红黑树为空树

```
最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。
	处理：把插入结点作为根结点，并把结点设置为黑色。
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101555691.png)

**插入场景2**：插入结点的父结点为黑结点
由于插入的结点是红色的，且父节点为黑色节点，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。
处理：直接插入。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101605799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

**插入场景3**：插入结点的父结点为红结点
再次回想下红黑树的性质2：根结点是黑色。如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。

**插入场景3.1**：叔叔结点存在并且为红结点
从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101620456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

实际案例：

祖父节点为根节点：红黑黑
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101633361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101641220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
祖父节点不为根节点：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021061510165390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101701673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

**插入场景3.2**：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点
单纯从插入前来看，也即不算情景3.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。

前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。

**插入场景3.2.1**：插入结点是其父结点的左子结点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101713390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101721638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101735670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

**插入场景3.2.2**：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101753762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101802168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615101811466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

#### 3.红黑树删除节点

&emsp;&emsp;红黑树的节点的删除其实也分为两步：

1. 先删除节点(这步和普通的二叉树删除是一样的)
2. 然后再调整

##### 1.删除节点

&emsp;&emsp;要删除这个节点先需要找到这个节点，找到节点就是普通的二分查找，具体代码如下

```java
    private RBNode getNode(K key){
        RBNode node = this.root;
        while (node != null ){
            int cmp = key.compareTo((K) node.key);
            if(cmp < 0){
                // 在左子树
                node = node.left;
            }else if(cmp >0){
                // 右子树
                node = node.right;
            }else{
                return node;
            }
        }
        return null;
    }
```

&emsp;&emsp;在整理红黑树节点的删除操作时我们需要先理解清楚红黑树删除和2-3-4树删除的等价关系，这样理解起来才会比较容易
&emsp;&emsp;核心理论：红黑树删除操作的本质其实就是删除2-3-4树的叶子节点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615102814219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
情况一
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615102829664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

情况2：删除的是非情况1的节点，根据我们前面介绍的删除的规则，会找到对应的前驱和后继节点，那么最终删除的还是叶子节点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615102845954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

首先删除节点的代码为：

```java
/**
     * 删除节点
     * @param key
     * @return
     */
    public V remove(K key){
        // 先找到这个节点
        RBNode node = getNode(key);
        if(node == null){
            return null;
        }
        // 把值存起来 删除后 返回
        V oldValue = (V) node.value;
        deleteNode(node);
        return oldValue;
    }

    /**
     * 删除节点
     *   3种情况
     * 1.删除叶子节点，直接删除
     * 2.删除的节点有一个子节点，那么用子节点来替代
     * 3.如果删除的节点右两个子节点，此时需要找到前驱节点或者后继节点来替代
     *    可以转换为 1、2的情况
     * @param node
     */
    private void deleteNode(RBNode node){
        // 3.node节点有两个子节点
        if(node.left !=null && node.right != null){
            // 找到要删除节点的后继节点
            RBNode successor = successor(node);
            // 然后用后继节点的信息覆盖掉 要删除节点的信息
            node.key = successor.key;
            node.value = successor.value;
            // 然后我们要删除的节点就变为了 后继节点
            node = successor;
        }
        // 2.删除有一个子节点的情况
        RBNode replacement = node.left != null ? node.left : node.right;
        if(replacement != null){
            // 替代者的父指针指向原来 node 的父节点
            replacement.parent = node.parent;
            if(node.parent == null){
                // 说明 node 是root节点
                root = replacement;
            }else if(node == node.parent.left){
                // 双向绑定
                node.parent.left = replacement;
            }else{
                node.parent.right = replacement;
            }
            // 将node的左右孩子指针和父指针都指向null node等待GC
            node.left = node.right = node.parent = null;
            // 替换完成后需要调整平衡
            if(node.color == BLACK){
                // fixAfterRemove(replacement)
            }
        }else if(node.parent == null){
            // 说明要删除的是root节点
            root = null;
        }else{
            // 1. node节点是叶子节点 replacement为null
            // 先调整
            if(node.color == BLACK){
                // fixAfterRemove(node)
            }
            // 再删除
            if(node.parent != null){
                if(node == node.parent.left){
                    node.parent.left = null;
                }else{
                    node.parent.right = null;
                }
                node = null;
            }
        }
    }
```

然后就是需要调整红黑树的平衡了。

##### 2.删除后的平衡调整

删除节点的调整操作：

1.情况一：自己能搞定的，对应叶子节点是3节点和4节点
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021061510304463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

2.情况二：自己搞不定，需要兄弟借，但是兄弟不借，找父亲借，父亲下来，然后兄弟找一个人去代替父亲当家

这种情况就是兄弟节点是3节点或者4节点

找兄弟节点![在这里插入图片描述](https://img-blog.csdnimg.cn/2021061510305744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
如果找到的兄弟节点是红色其实还要调整
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103107322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

执行如下调整先,先变色，然后左旋
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103121371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103128132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

找兄弟节点借
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103140466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
然后沿着7节点左旋

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103154827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

3.情况三：跟兄弟借，兄弟也没有（情同手足，同时自损）

兄弟节点是2节点，同时当前节点的父节点是红色节点的情况

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103211307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
删除后直接变色就可以了

兄弟节点是2节点，同时当前节点的父节点是黑色节点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103224718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)
变更操作为如下，如果继续有父节点那么还要递归处理
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615103236179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70)

分析清楚了删除的3中情况，我们就可以撸处删除的调整的代码了

```java
    /**
     * 2-3-4树删除操作：
     * 1.情况一：自己能搞定的，对应叶子节点是3节点和4节点
     * 2.情况二：自己搞不定，需要兄弟借，但是兄弟不借，找父亲借，父亲下来，然后兄弟找一个人去代替父亲当家
     * 3.情况三：跟兄弟借，兄弟也没有
     * @param x
     */
    private void fixAfterRemove(RBNode x){
        // 情况2、3
        while(x != root && colorOf(x) == BLACK){
            // 这种情况才需要调整
            // x 是左孩子的情况
            if(x == leftOf(parentOf(x))){
                // 找兄弟节点
                RBNode rNode = rightOf(parentOf(x));
                // 判断此时的兄弟节点是否是真正的兄弟节点 兄弟是红色的情况要调整
                if(colorOf(rNode) == RED){ // 2-3-4树的 3节点 交换颜色，然后左旋一次就可以了
                    setColor(rNode,BLACK);
                    setColor(parentOf(x),RED);
                    leftRotate(parentOf(x)); // 左旋一次
                    rNode = rightOf(parentOf(x)); // 找到真正的兄弟节点
                }
                // 情况3 找兄弟借 没得借
                if(colorOf(leftOf(rNode)) == BLACK && colorOf(rightOf(rNode)) == BLACK){
                    // 情况复杂
                    setColor(rNode,RED);
                    x=parentOf(x); // 向上递归
                }else{
                    // 情况2 找兄弟借 有借
                    // 兄弟节点是 3节点或者4节点
                    if(colorOf(rightOf(rNode)) == BLACK){
                        // 右孩子为空，则左孩子肯定不为空
                        // 兄弟节点 先要左一次右旋
                        setColor(rNode,RED);
                        setColor(leftOf(rNode),BLACK);
                        rightRotate(rNode);
                        // 重新调整叔叔节点的位置
                        rNode = rightOf(parentOf(x));
                    }
                    // 变色  兄弟节点是 3节点还是4节点 都旋转一次
                    setColor(rNode, colorOf(parentOf(x)));
                    setColor(parentOf(x),BLACK);
                    setColor(rightOf(rNode),BLACK);
                    // 左旋
                    leftRotate(parentOf(x));
                    x = root; // 结束循环  递归 针对的是 情况3
                }
            }else{
                // 找兄弟节点
                RBNode rNode = leftOf(parentOf(x));
                // 判断此时的兄弟节点是否是真正的兄弟节点 兄弟是红色的情况要调整
                if(colorOf(rNode) == RED){ // 2-3-4树的 3节点 交换颜色，然后左旋一次就可以了
                    setColor(rNode,BLACK);
                    setColor(parentOf(x),RED);
                    rightRotate(parentOf(x)); // 左旋一次
                    rNode = leftOf(parentOf(x)); // 找到真正的兄弟节点
                }
                // 情况3 找兄弟借 没得借
                if(colorOf(rightOf(rNode)) == BLACK && colorOf(leftOf(rNode)) == BLACK){
                    // 情况复杂
                    setColor(rNode,RED);
                    x=parentOf(x); // 向上递归
                }else{
                    // 情况2 找兄弟借 有借
                    // 兄弟节点是 3节点或者4节点
                    if(colorOf(leftOf(rNode)) == BLACK){
                        // 右孩子为空，则左孩子肯定不为空
                        // 兄弟节点 先要左一次右旋
                        setColor(rNode,RED);
                        setColor(leftOf(rNode),BLACK);
                        leftRotate(rNode);
                        // 重新调整叔叔节点的位置
                        rNode = leftOf(parentOf(x));
                    }
                    // 变色  兄弟节点是 3节点还是4节点 都旋转一次
                    setColor(rNode, colorOf(parentOf(x)));
                    setColor(parentOf(x),BLACK);
                    setColor(leftOf(rNode),BLACK);
                    // 左旋
                    rightRotate(parentOf(x));
                    x = root; // 结束循环  递归 针对的是 情况3
                }
            }
        }
        // 情况1：替代节点是红色，直接染黑  在情况3的情况下  补偿删除的黑色节点，这样红黑树依然保存平衡
        setColor(x,BLACK);
    }
```

### 2.5 B树和B+树

#### 2.5.1 B树

&emsp;&emsp;（Balanced Tree）
&emsp;&emsp;这个就是我们的多路平衡查找树，叫做B-Tree（B代表平衡）。
&emsp;&emsp;跟AVL树一样，B树在枝节点和叶子节点存储键值、数据地址、节点引用。
&emsp;&emsp;它有一个特点：分叉数（路数）永远比关键字数多1。比如我们画的这棵树，每个节点存储两个关键字，那么就会有三个指针指向三个子节点。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/101487c11a01465a9f52b10da894f7ad.png)

&emsp;&emsp;B Tree的查找规则是什么样的呢？
&emsp;&emsp;比如我们要在这张表里面查找15。
&emsp;&emsp;因为15小于17，走左边。
&emsp;&emsp;因为15大于12，走右边。
&emsp;&emsp;在磁盘块7里面就找到了15，只用了3次IO。

&emsp;&emsp;这个是不是比AVL 树效率更高呢？
&emsp;&emsp;那B Tree又是怎么实现一个节点存储多个关键字，还保持平衡的呢？跟AVL树有什么区别？
https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
&emsp;&emsp;比如Max Degree（路数）是3的时候，我们插入数据1、2、3，在插入3的时候，本来应该在第一个磁盘块，但是如果一个节点有三个关键字的时候，意味着有4个指针，子节点会变成4路，所以这个时候必须进行分裂（其实就是B+Tree）。把中间的数据2提上去，把1和3变成2的子节点。
&emsp;&emsp;如果删除节点，会有相反的合并的操作。
&emsp;&emsp;注意这里是分裂和合并，跟AVL树的左旋和右旋是不一样的。
&emsp;&emsp;我们继续插入4和5，B Tree又会出现分裂和合并的操作。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201107193205952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70#pic_center)
&emsp;&emsp;从这个里面我们也能看到，在更新索引的时候会有大量的索引的结构的调整，所以解释了为什么我们不要在频繁更新的列上建索引，或者为什么不要更新主键。
&emsp;&emsp;节点的分裂和合并，其实就是InnoDB页（page）的分裂和合并。

#### 2.5.2 B+树

&emsp;&emsp;加强版多路平衡查找树
&emsp;&emsp;因为B Tree的这种特性非常适合用于做索引的数据结构，所以很多文件系统和数据库的索引都是基于B Tree的。
&emsp;&emsp;但是实际上，MySQL里面使用的是B Tree的改良版本，叫做B+Tree（加强版多路平衡查找树）。

B+树的存储结构：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/0329ff947bb0430fb4c75fd160a8a0f6.png)

MySQL中的B+Tree有几个特点：

1. 它的关键字的数量是跟路数相等的；
2. B+Tree的根节点和枝节点中都不会存储数据，只有叶子节点才存储数据。InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。搜索到关键字不会直接返回，会到最后一层的叶子节点。比如我们搜索id=28，虽然在第一层直接命中了，但是全部的数据在叶子节点上面，所以我还要继续往下搜索，一直到叶子节点。
3. B+Tree的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数据会指向下一个叶子节点的第一个数据，形成了一个有序链表的结构。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/aff507c7e9c84358b60e58b2edec627a.png)总结一下， B+Tree的特点带来的优势：

1. 它是B Tree的变种，B Tree能解决的问题，它都能解决。B Tree解决的两大问题是什么？（每个节点存储更多关键字；路数更多）
2. 扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵B+Tree拿到所有的数据）
3. B+Tree的磁盘读写能力相对于B Tree来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）
4. 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）
5. 效率更加稳定（B+Tree永远是在叶子节点拿到数据，所以IO次数是稳定的）

# 二、集合API源码分析

程序=数据结构+算法

## 1. 集合概述

集合是存储数据的容器

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/3b6773daa17647c99215d97c819f934e.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/f01a7a03f1274ed5a12f213f0b40ef56.png)

## 2. ArrayList详解

### 2.1 类图结构

首先我们来看下ArrayList的类图结构

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/cf6a47b5e0164db4acc06eba469db962.png)

### 2.2 源码分析

#### 2.2.1 声明的属性

| 属性                              | 作用                                |
| --------------------------------- | ----------------------------------- |
| DEFAULT_CAPACITY                  | 默认的数组容量                      |
| EMPTY_ELEMENTDATA                 | 用于共享的空实例数组                |
| DEFAULTCAPACITY_EMPTY_ELEMENTDATA | 也是一个空的实例数组                |
| elementData                       | 这个是ArrayList中真实存储数据的容器 |
| size                              | 记录集合中的元素的个数              |

#### 2.2.2 构造方法

```java
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }

public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}

public ArrayList(Collection<? extends E> c) {
    // 将传递的集合转换为数组 然后赋值给了 elementData
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
```

都很简单，就不一一的记录描述了。

#### 2.2.3 添加方法

| 方法名                                                      | 描述                                                                     |
| ----------------------------------------------------------- | ------------------------------------------------------------------------ |
| public boolean add(E e)                                     | 将指定的元素追加到此列表的末尾。                                         |
| public void add(int index, E element)                       | 在此列表中的指定位置插入指定的元素。                                     |
| public boolean addAll(Collection<?> c )                     | 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 |
| public boolean addAll(i nt index,Collection<? extends E> c) | 将指定集合中的所有元素插入到此列表中，从指定的位置开始。                 |

**add(E e)**

```java
    public boolean add(E e) {
        // 校验内部容量
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```

```java
    private void ensureCapacityInternal(int minCapacity) {
        // calculateCapacity计算容量
        // ensureExplicitCapacity 继续校验
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
```

calculateCapacity方法

```java
    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        // 判断集合存数据的数组是否等于空容量的数组
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            // 通过最小容量和默认容量 求出较大值 (用于第一次扩容)
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }
```

ensureExplicitCapacity方法

```java
private void ensureExplicitCapacity(int minCapacity) { 
    //实际修改集合次数++ (在扩容的过程中没用,主要是用于迭代器中) 
    modCount++; 
    //判断最小容量 - 数组长度是否大于 0 
    if (minCapacity - elementData.length > 0) 
        //将第一次计算出来的容量传递给 核心扩容方法 
        grow(minCapacity); 
}
```

```java
private void grow(int minCapacity) { 
    //记录数组的实际长度,此时由于木有存储元素,长度为0 
    int oldCapacity = elementData.length; 
    //核心扩容算法 原容量的1.5倍 
    int newCapacity = oldCapacity + (oldCapacity >> 1); 
    //判断新容量 - 最小容量 是否小于 0, 如果是第一次调用add方法必然小于 
    if (newCapacity - minCapacity < 0) 
        //还是将最小容量赋值给新容量 
        newCapacity = minCapacity; 
    //判断新容量-最大数组大小 是否>0,如果条件满足就计算出一个超大容量 
    if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); 
    // 调用数组工具类方法,创建一个新数组,将新数组的地址赋值给
    elementData elementData = Arrays.copyOf(elementData, newCapacity); 
}
```

**add(int index, E element)**

```java
    public void add(int index, E element) {
        // 检查index的合法性
        rangeCheckForAdd(index);
		 // 校验内部容量
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        // index = 3
        // [1,2,3,4,5] --> [1,2,3, ,4,5]
        // 将 elementData index=3后的元素复制到 elementData 的 index+1=4后的位置
        // 也就是空出来了 index 的位置
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
```

**addAll(Collection<?> c )**

```java
public boolean addAll(Collection<? extends E> c) {
    //把集合的元素转存到Object类型的数组中
    Object[] a = c.toArray();
    //记录数组的长度
    int numNew = a.length;
    //调用方法检验是否要扩容,且让增量++
    ensureCapacityInternal(size + numNew);  // Increments modCount
    //调用方法将a数组的元素拷贝到elementData数组中
    System.arraycopy(a, 0, elementData, size, numNew);
    //集合的长度+=a数组的长度
    size += numNew;
    //只要a数组的长度不等于0,即说明添加成功
    return numNew != 0;
}
```

**addAll(i nt index,Collection<? extends E> c)**

```java
    public boolean addAll(int index, Collection<? extends E> c) {
        // 校验index是否合法
        rangeCheckForAdd(index);
		// 传递进来的集合转换为数组
        Object[] a = c.toArray();
        // 记录数组的长度
        int numNew = a.length;
        // 校验是否要扩容
        ensureCapacityInternal(size + numNew);  // Increments modCount
		// 计算 数组要插入到 集合的index 下标
        int numMoved = size - index;
        if (numMoved > 0)
            // 调整 elementData 中的数据的位置 给新插入的数据流出空间
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
		// 将数据中的数据插入到新的数组对应的位置中即可
        System.arraycopy(a, 0, elementData, index, numNew);
        // 集合容量增加
        size += numNew;
        return numNew != 0;
    }
```

其他方法的实现都很简单，请自行查阅。

## 3. Vector

### 3.1 类图结构

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/c77b5949598240d9bb6b2cd122c1b283.png)

### 3.2 和ArrayList的区别

```
本质上也是通过数组的形式来实现的，只是在每个实现的方法中都添加了一个synchronized关键字，所以Vector是数据安全的。
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/7cb06a3313694b6c9c4000ab9bda84bf.png)

## 4. HashSet

### 4.1 类图结构

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/b0ce94b8678b43acbf97f24beed5cefa.png)

### 4.2  HashSet的本质

HashSet的本质其实就是HashMap，这个我们可以通过HashSet的构造方法可以看到

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/875f955c6fc2429199d4d235b4e4a425.png)

所以我们要搞清楚HashSet本质上搞清楚了HashMap就可以了，所以此处我们不过多讲解。重点是后面的HashMap。

## 5.TreeSet

### 5.1 类图结构

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/0fd56b02e37e44a58088e448504f08e8.png)

### 5.2 TreeSet的本质

```
和HashSet一样，TreeSet的功能也不是自己来实现的，而是借助TreeMap来实现的，在TreeSet的构造方法中我们可以看到
```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/49896e49c6804111927d26049c656613.png)

## 6.TreeMap

### 6.1 类图结构

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/61c53feb0e864497b5c2929dd72262c6.png)

### 6.2 源码分析

通过前面红黑树的介绍，其实大家已经对红黑树的节点的添加，删除都很清楚，而且TreeMap实现的本质就是红黑树，所以TreeMap的源码大家应该很容易看懂。具体如下：

#### 6.2.1 成员变量

```java
   	// 比较器
	private final Comparator<? super K> comparator;
	// 根节点 Entry 相当于之前的 RBNode 类型
    private transient Entry<K,V> root;

    /**
     * The number of entries in the tree
     */
    private transient int size = 0;

    /**
     * The number of structural modifications to the tree.
     */
    private transient int modCount = 0;
```

Entry的具体声明

```java
    static final class Entry<K,V> implements Map.Entry<K,V> {
        K key;
        V value;
        Entry<K,V> left;
        Entry<K,V> right;
        Entry<K,V> parent;
        boolean color = BLACK;
    }
```

#### 6.2.2 put方法

```java
   public V put(K key, V value) {
       // 1.查找插入的位置
        Entry<K,V> t = root;
       // 第一次插入  插入的节点设置为 root 节点
        if (t == null) {
            compare(key, key); // type (and possibly null) check

            root = new Entry<>(key, value, null);
            size = 1; // 记录集合中的元素个数
            modCount++; // 记录操作的次数
            return null;
        }
        int cmp; // 比较的值
        Entry<K,V> parent; // 记录插入节点的父节点
        // split comparator and comparable paths
        Comparator<? super K> cpr = comparator;
        if (cpr != null) { // 比较器不为空
            // 遍历找到插入的位置
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                     // 插入的值在容器中有相同的值 直接覆盖
                    return t.setValue(value);
            } while (t != null);
        }
        else {
            if (key == null)
                throw new NullPointerException();
            // 比较器为空就创建一个比较器
            @SuppressWarnings("unchecked")
                Comparable<? super K> k = (Comparable<? super K>) key;
            // 找到插入的位置
            do {
                parent = t;
                cmp = k.compareTo(t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
       // 需要插入的 k v 对封装为 Entry对象
        Entry<K,V> e = new Entry<>(key, value, parent);
        if (cmp < 0)
            parent.left = e;
        else
            parent.right = e;
       // 变色和调整操作
        fixAfterInsertion(e);
        size++;
        modCount++;
        return null;
    }
```

fixAfterInsertion(e)方法：

```java
   private void fixAfterInsertion(Entry<K,V> x) {
       // 插入节点 默认就是红色节点
        x.color = RED;
		// 只有 插入节点的 父节点是 黑色节点才需要 调整平衡
        while (x != null && x != root && x.parent.color == RED) {
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                // 插入节点的 父亲节点是 爷爷节点的左节点
                // 获取叔叔节点
                Entry<K,V> y = rightOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    // 存在叔叔节点
                    // 父亲和叔叔节点 变为黑色
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    // 爷爷节点变为红色
                    setColor(parentOf(parentOf(x)), RED);
                    // 将插入节点调整为 爷爷节点 然后递归处理
                    x = parentOf(parentOf(x));
                } else {
                    // 没有叔叔节点
                    if (x == rightOf(parentOf(x))) {
                        // 插入节点是父节点的右子节点 需要先根据父亲节点左旋一次
                        //    6           6
                        //   /           /
                        //  4   ==>     5
                        //   \         /
                        //    5       4
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    // 然后父亲节点设置为 黑色 爷爷节点设置为红色
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    // 右旋一次即可
                    rotateRight(parentOf(parentOf(x)));
                }
            } else {
                // 和上面的情况刚好相反
                Entry<K,V> y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
       // 将 root 节点设置为 黑色节点
        root.color = BLACK;
    }
```

通过源码分析大家应该发现和我们在红黑树中的添加的代码是一模一样的。同样的大家可以自行看下左旋和右旋的代码。也很简单哦

## 7. HashMap

### 7.1 设计原理

&emsp;&emsp;HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null，此外，HashMap 中的映射不是有序的。

&emsp;&emsp;jdk1.8 之前 HashMap 由 数组 + 链表 组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突（两个对象调用的 hashCode 方法计算的哈希值经哈希函数算出来的地址被别的元素占用）而存在的（“拉链法”解决冲突）。jdk1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8 ）并且当前数组的长度大于 64 时，此时此索引位置上的所有数据改为使用红黑树存储。

**补充**：将链表转换成红黑树前会判断，即便阈值大于 8，但是数组长度小于 64，此时并不会将链表变为红黑树，而是选择逬行数组扩容。

&emsp;&emsp;这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要逬行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以结上所述为了提高性能和减少搜索时间，底层阈值大于8并且数组长度大于64时，链表才转换为红黑树，具体可以参考 treeifyBin() 方法。

&emsp;&emsp;当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于 8 并且数组长度大于 64 时，链表转换为红黑树时，效率也变的更高效。

HashMap 特点：

1. 存储无序的。
2. 键和值位置都可以是 null，但是键位置只能存在一个 null。
3. 键位置是唯一的，是底层的数据结构控制的。
4. jdk1.8 前数据结构是链表+数组，jdk1.8 之后是链表+数组+红黑树。
5. 阈值（边界值）> 8 并且数组长度大于 64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。

#### 7.1.1 JDK1.7

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/3f3d00c1a29e4ab0ad80592f0020ad77.png)

#### 7.1.2 JDK1.8

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/029a00691e704d44be926e751176efbf.png)

#### 7.1.3 扩容

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/f4dd24883e2b4819a85749fe31abe339.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/bfaf576fbe034442a069dd33b064a296.png)

### 7.2 源码分析

#### 7.2.1 成员变量

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/16aea231a59d40a583e1d2d923195b1c.png)

**serialVersionUID**

序列化版本号

**DEFAULT_INITIAL_CAPACITY**

集合的初始化容量（必须是 2 的 n 次幂）

```java
// 默认的初始容量是16	1 << 4 相当于 1*2的4次方
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
```

**DEFAULT_LOAD_FACTOR**

默认的负载因子（默认值 0.75）

```java
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

**MAXIMUM_CAPACITY**

集合最大容量

```java
static final int MAXIMUM_CAPACITY = 1 << 30; // 2的30次幂
```

**TREEIFY_THRESHOLD**

当链表的值超过8则会转为红黑树（jdk1.8新增）

```java
// 当桶（bucket）上的结点数大于这个值时会转为红黑树
static final int TREEIFY_THRESHOLD = 8;
```

**UNTREEIFY_THRESHOLD**

当链表的值小于 6 则会从红黑树转回链表

```java
// 当桶（bucket）上的结点数小于这个值，树转为链表 
static final int UNTREEIFY_THRESHOLD = 6;
```

**MIN_TREEIFY_CAPACITY**

当 Map 里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于4*TREEIFY_THRESHOLD(8)

```java
// 桶中结构转化为红黑树对应的数组长度最小的值 
static final int MIN_TREEIFY_CAPACITY = 64;
```

**table**

table 用来初始化（必须是二的n次幂）(重点)

```java
// 存储元素的数组 
transient Node<K,V>[] table;
```

在 jdk1.8 中我们了解到 HashMap 是由数组加链表加红黑树来组成的结构，其中 table 就是 HashMap 中的数组，jdk8 之前数组类型是 Entry<K,V> 类型。从 jdk1.8 之后是 Node<K,V> 类型。只是换了个名字，都实现了一样的接口：Map.Entry<K,V>。负责存储键值对数据的。

**entrySet**

用来存放缓存

```java
// 存放具体元素的集合
transient Set<Map.Entry<K,V>> entrySet;
```

**size**

HashMap 中存放元素的个数(重点)

```java
// 存放元素的个数，注意这个不等于数组的长度
 transient int size;
```

size 为 HashMap 中 K-V 的实时数量，不是数组 table 的长度。

**modCount**

用来记录 HashMap 的修改次数

```java
// 每次扩容和更改 map 结构的计数器
 transient int modCount;  
```

**threshold**

用来调整大小下一个容量的值计算方式为（容量*负载因子）

```java
// 临界值 当实际大小（容量*负载因子）超过临界值时，会进行扩容
int threshold;
```

**loadFactor**

哈希表的负载因子(重点)

```java
// 负载因子
final float loadFactor;
```

#### 7.2.2 构造方法

**HashMap()**

构造一个空的HashMap，默认初始容量（16）和默认负载因子（0.75）

```java
public HashMap() {
    // 将默认的负载因子0.75赋值给loadFactor，并没有创建数组
   this.loadFactor = DEFAULT_LOAD_FACTOR; 
}
```

**HashMap(int initialCapacity)**

构造一个具有指定的初始容量和默认负载因子（0.75）HashMap 。

```java
 // 指定“容量大小”的构造函数
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

```

**HashMap(int initialCapacity, float loadFactor)**

构造一个具有指定的初始容量和负载因子的 HashMap。

```java
/*
	 指定“容量大小”和“负载因子”的构造函数
	 initialCapacity：指定的容量
	 loadFactor:指定的负载因子
*/
public HashMap(int initialCapacity, float loadFactor) {
    	// 判断初始化容量initialCapacity是否小于0
        if (initialCapacity < 0)
            // 如果小于0，则抛出非法的参数异常IllegalArgumentException
            throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
    	// 判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY
        if (initialCapacity > MAXIMUM_CAPACITY)
            // 如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity
            initialCapacity = MAXIMUM_CAPACITY;
    	// 判断负载因子loadFactor是否小于等于0或者是否是一个非数值
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            // 如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException
            throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
     	// 将指定的负载因子赋值给HashMap成员变量的负载因子loadFactor
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
// 最后调用了tableSizeFor，来看一下方法实现：
     /*
     	返回比指定初始化容量大的最小的2的n次幂
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

```

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/16ebe5d67c1f4117ad693566d96256e3.png)

**HashMap(Map<? extends K, ? extends V> m)**

包含另一个 “Map” 的构造函数

```java
// 构造一个映射关系与指定 Map 相同的新 HashMap。
public HashMap(Map<? extends K, ? extends V> m) {
    	// 负载因子loadFactor变为默认的负载因子0.75
         this.loadFactor = DEFAULT_LOAD_FACTOR;
         putMapEntries(m, false);
 }
```

最后调用了 putMapEntries()，来看一下方法实现：

```java
final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
    //获取参数集合的长度
    int s = m.size();
    if (s > 0) {
        //判断参数集合的长度是否大于0，说明大于0
        if (table == null) { // 判断table是否已经初始化
                // 未初始化，s为m的实际元素个数
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft < (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY);
                // 计算得到的t大于阈值，则初始化阈值
                if (t > threshold)
                    threshold = tableSizeFor(t);
        }
        // 已初始化，并且m元素个数大于阈值，进行扩容处理
        else if (s > threshold)
            resize();
        // 将m中的所有元素添加至HashMap中
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}

```

注意：

float ft = ((float)s / loadFactor) + 1.0F; 这一行代码中为什么要加 1.0F ？

s/loadFactor 的结果是小数，加 1.0F 与 (int)ft 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数。所以 + 1.0F 是为了获取更大的容量。

例如：原来集合的元素个数是 6 个，那么 6/0.75 是8，是 2 的n次幂，那么新的数组大小就是 8 了。然后原来数组的数据就会存储到长度是 8 的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果 +1 呢，数组长度直接变为16了，这样可以减少数组的扩容。

#### 7.2.3  put方法

put方法的实现文字说明：

1. 先通过 hash 值计算出 key 映射到哪个桶；
2. 如果桶上没有碰撞冲突，则直接插入；
3. 如果出现碰撞冲突了，则需要处理冲突：

   - a 如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；
   - b 否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；
4. 如果桶中存在重复的键，则为该键替换新值 value；
5. 如果 size 大于阈值 threshold，则进行扩容；

put方法的源码说明

```java
public V put(K key, V value) {
	return putVal(hash(key), key, value, false, true);
}
/**
 * hash：key 的 hash 值
 * key：原始 key
 * value：要存放的值
 * onlyIfAbsent：如果 true 代表不更改现有的值
 * evict：如果为false表示 table 为创建状态
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    /*
    	1）transient Node<K,V>[] table; 表示存储Map集合中元素的数组。
    	2）(tab = table) == null 表示将空的table赋值给tab，然后判断tab是否等于null，第一次肯定是null。
    	3）(n = tab.length) == 0 表示将数组的长度0赋值给n，然后判断n是否等于0，n等于0，由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化，并将初始化好的数组长度赋值给n。
    	4）执行完n = (tab = resize()).length，数组tab每个空间都是null。
    */
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    /*
    	1）i = (n - 1) & hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中。
    	2）p = tab[i = (n - 1) & hash]表示获取计算出的位置的数据赋值给结点p。
    	3) (p = tab[i = (n - 1) & hash]) == null 判断结点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的结点放入该位置的桶中。
        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置。
    */ 
    if ((p = tab[i = (n - 1) & hash]) == null)
        // 创建一个新的结点存入到桶中
        tab[i] = newNode(hash, key, value, null);
    else {
         // 执行else说明tab[i]不等于null，表示这个位置已经有值了
        Node<K,V> e; K k;
        /*
        	比较桶中第一个元素(数组中的结点)的hash值和key是否相等
        	1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个hash值是否相等。
                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。
                    Node<K,V> newNode(int hash, K key, V value, Node<K,V> next) {
                        return new Node<>(hash, key, value, next);
                    }
                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的。
             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key比较两个key的地址值是否相等。
             3）key != null && key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等。
        */
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
                /*
                	说明：两个元素哈希值相等，并且key的值也相等，将旧的元素整体对象赋值给e，用e来记录
                */ 
                e = p;
        // hash值不相等或者key不相等；判断p是否为红黑树结点
        else if (p instanceof TreeNode)
            // 放入树中
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // 说明是链表结点
        else {
            /*
            	1)如果是链表的话需要遍历到最后结点然后插入
            	2)采用循环遍历的方式，判断链表中是否有重复的key
            */
            for (int binCount = 0; ; ++binCount) {
                /*
                	1)e = p.next 获取p的下一个元素赋值给e。
                	2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键，将该键值对插入链表中。
                */
                if ((e = p.next) == null) {
                    /*
                    	1）创建一个新的结点插入到尾部
                    	 p.next = newNode(hash, key, value, null);
                    	 Node<K,V> newNode(int hash, K key, V value, Node<K,V> next) {
                                return new Node<>(hash, key, value, next);
                         }
                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个结点肯定是null。
                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素。
                    */
                    p.next = newNode(hash, key, value, null);
                    /*
                    	1)结点添加完成之后判断此时结点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树。
                    	2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历结点的个数。值是0表示第一个结点，1表示第二个结点。。。。7表示第八个结点，加上数组中的的一个元素，元素个数是9。
                    	TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7
                    	如果binCount的值是7(加上数组中的的一个元素，元素个数是9)
                    	TREEIFY_THRESHOLD - 1也是7，此时转换红黑树。
                    */
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        // 转换为红黑树
                        treeifyBin(tab, hash);
                    // 跳出循环
                    break;
                }
       
                /*
                	执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插入的元素的key值是否相等。
                */
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    // 相等，跳出循环
                    /*
                		要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了
                		直接执行下面的if语句去替换去 if (e != null) 
                	*/
                    break;
                /*
                	说明新添加的元素和当前结点不相等，继续查找下一个结点。
                	用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
                */
                p = e;
            }
        }
        /*
        	表示在桶中找到key值、hash值与插入元素相等的结点
        	也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值
        	这里完成了put方法的修改功能
        */
        if (e != null) { 
            // 记录e的value
            V oldValue = e.value;
            // onlyIfAbsent为false或者旧值为null
            if (!onlyIfAbsent || oldValue == null)
                // 用新值替换旧值
                // e.value 表示旧值  value表示新值 
                e.value = value;
            // 访问后回调
            afterNodeAccess(e);
            // 返回旧值
            return oldValue;
        }
    }
    // 修改记录次数
    ++modCount;
    // 判断实际大小是否大于threshold阈值，如果超过则扩容
    if (++size > threshold)
        resize();
    // 插入后回调
    afterNodeInsertion(evict);
    return null;
}

```

上面的源码中使用到了hash方法，我们来看下hash方法的源码

```java
static final int hash(Object key) {
	int h;
	/*
	1）如果key等于null：返回的是0.
	2）如果key不等于null：首先计算出key的hashCode赋值给h，然后与h无符号右移16位后的
		二进制进行按位异或得到最后的hash值
	*/
	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

从上面可以得知 HashMap 是支持 key 为空的，而 HashTable 是直接用 Key 来获取hashCode 所以 key 为空会抛异常。

(n - 1) & hash 的实现介绍：

- key.hashCode()；返回散列值也就是 hashcode，假设随便生成的一个值。
- n 表示数组初始化的长度是 16。
- &（按位与运算）：运算规则：相同的二进制数位上，都是 1 的时候，结果为 1，否则为0。
- ^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为 0，不同为 1。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/435857a2ba5e49da88a05245ba8f1d30.png)

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/a9f2dbf47655493a86051e0f5d2f3f77.png)

#### 7.2.4 treeifyBin()

结点添加完成之后判断此时结点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：

```java
if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
   //转换为红黑树 tab表示数组名  hash表示哈希值
   treeifyBin(tab, hash);

```

treeifyBin 方法如下所示

```java
/*
	替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。
	Node<K,V>[] tab = tab 数组名
	int hash = hash表示哈希值
*/
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    /*
    	如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)，就去扩容。而不是将结点变为红黑树。
    	目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。
    */
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        //扩容方法
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        /*
        	1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化
        	2）e = tab[index = (n - 1) & hash]表示将数组中的元素取出赋值给e，e是哈希表中指定位置桶里的链表结点，从第一个开始
        */
        // hd：红黑树的头结点   tl：红黑树的尾结点
        TreeNode<K,V> hd = null, tl = null;
        do {
            // 新创建一个树的结点，内容和当前链表结点e一致
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p; // 将新创键的p结点赋值给红黑树的头结点
            else {
                p.prev = tl; // 将上一个结点p赋值给现在的p的前一个结点
                tl.next = p; // 将现在结点p作为树的尾结点的下一个结点
            }
            tl = p;
            /*
            	e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null
            	则回到上面继续取出链表中结点转换为红黑树
            */
        } while ((e = e.next) != null);
        /*
        	让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树
        	而不是链表数据结构了
        */
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}

```

小结：

1. 根据哈希表中元素个数确定是扩容还是树形化。
2. 如果是树形化遍历桶中的元素，创建相同个数的树形结点，复制内容，建立起联系。
3. 然后让桶中的第一个元素指向新创建的树根结点，替换桶的链表内容为树形化内容。

#### 7.2.5 扩容方法

扩容机制：

**什么时候才需要扩容**

&emsp;&emsp;当 HashMap 中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor 的默认值是 0.75。

**HashMap 的扩容是什么**

&emsp;&emsp;进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n - 1) & hash 的结果相比，只是多了一个 bit 位，所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。

例如我们从 16 扩展为 32 时，具体的变化如下所示：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/8043791d9be44a998ab8b7e4a42b25cc.png)

因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n - 1 的标记范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/c6b2c3530fc04c4cbb07c3cb405f7b7f.png)

**说明：**

5 是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。

因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了，是 0 的话索引没变，是 1 的话索引变成 “原位置 + 旧容量” 。可以看看下图为 16 扩充为 32 的 resize 示意图：

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1670913800031/8c1212a8af824a0fb41f22050bc0a524.png)

正是因为这样巧妙的 rehash 方式，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，在 resize 的过程中保证了 rehash 之后每个桶上的结点数一定小于等于原来桶上的结点数，保证了 rehash 之后不会出现更严重的 hash 冲突，均匀的把之前的冲突的结点分散到新的桶中了。

resize源码分析

```java
final Node<K,V>[] resize() {
    // 得到当前数组
    Node<K,V>[] oldTab = table;
    // 如果当前数组等于null长度返回0，否则返回当前数组的长度
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    //当前阀值点 默认是12(16*0.75)
    int oldThr = threshold;
    int newCap, newThr = 0;
    // 如果老的数组长度大于0
    // 开始计算扩容后的大小
    if (oldCap > 0) {
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap >= MAXIMUM_CAPACITY) {
            // 修改阈值为int的最大值
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        /*
        	没超过最大值，就扩充为原来的2倍
        	1) (newCap = oldCap << 1) < MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量
        	2）oldCap >= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16
        */
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            // 阈值扩大一倍
            newThr = oldThr << 1; // double threshold
    }
    // 老阈值点大于0 直接赋值
    else if (oldThr > 0) // 老阈值赋值给新的数组长度
        newCap = oldThr;
    else { // 直接使用默认值
        newCap = DEFAULT_INITIAL_CAPACITY;//16
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 计算新的resize最大上限
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    // 新的阀值 默认原来是12 乘以2之后变为24
    threshold = newThr;
    // 创建新的哈希表
    @SuppressWarnings({"rawtypes","unchecked"})
    //newCap是新的数组长度--》32
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    // 判断旧数组是否等于空
    if (oldTab != null) {
        // 把每个bucket都移动到新的buckets中
        // 遍历旧的哈希表的每个桶，重新计算桶里元素的新位置
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                // 原来的数据赋值为null 便于GC回收
                oldTab[j] = null;
                // 判断数组是否有下一个引用
                if (e.next == null)
                    // 没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入
                    newTab[e.hash & (newCap - 1)] = e;
                //判断是否是红黑树
                else if (e instanceof TreeNode)
                    // 说明是红黑树来处理冲突的，则调用相关方法把树分开
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // 采用链表处理冲突
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    // 通过上述讲解的原理来计算结点的新位置
                    do {
                        // 原索引
                        next = e.next;
                     	// 这里来判断如果等于true e这个结点在resize之后不需要移动位置
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 原索引+oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}

```

#### 7.2.6 remove方法

&emsp;&emsp;删除方法就是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候要转链表。

```java
// remove方法的具体实现在removeNode方法中，所以我们重点看下removeNode方法
public V remove(Object key) {
        Node<K,V> e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
```

removeNode() 方法：

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
	// 根据hash找到位置 
	// 如果当前key映射到的桶不为空
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (p = tab[index = (n - 1) & hash]) != null) {
        Node<K,V> node = null, e; K k; V v;
        // 如果桶上的结点就是要找的key，则将node指向该结点
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            // 说明结点存在下一个结点
            if (p instanceof TreeNode)
                // 说明是以红黑树来处理的冲突，则获取红黑树要删除的结点
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                // 判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的结点
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        // 比较找到的key的value和要删除的是否匹配
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            // 通过调用红黑树的方法来删除结点
            if (node instanceof TreeNode)
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                // 链表删除
                tab[index] = node.next;
            else
                p.next = node.next;
            // 记录修改次数
            ++modCount;
            // 变动的数量
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
```

#### 7.2.7 get方法

查找方法，通过元素的 key 找到 value，这个方法就比较好理解了

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
```

get 方法主要调用的是 getNode 方法，代码如下：

```java
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    // 如果哈希表不为空并且key对应的桶上不为空
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        /* 
        	判断数组元素是否相等
        	根据索引的位置检查第一个元素
        	注意：总是检查第一个元素
        */
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        // 如果不是第一个元素，判断是否有后续结点
        if ((e = first.next) != null) {
            // 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取结点
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            do {
                // 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

### 7.3 面试相关

1. HashMap 中 hash 函数是怎么实现的？还有哪些hash函数的实现方式？
   答：对于 key 的 hashCode 做 hash 操作，无符号右移 16 位然后做异或运算。还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移 16 位异或运算效率是最高的。
2. 当两个对象的 hashCode 相等时会怎么样？
   答：会产生哈希碰撞。若 key 值内容相同则替换旧的 value，不然连接到链表后面，链表长度超过阈值 8 就转换为红黑树存储。
3. 什么是哈希碰撞，如何解决哈希碰撞？
   答：只要两个元素的 key 计算的哈希码值相同就会发生哈希碰撞。jdk8 之前使用链表解决哈希碰撞。jdk8之后使用链表 + 红黑树解决哈希碰撞。
4. 如果两个键的 hashCode 相同，如何存储键值对？
   答：通过 equals 比较内容是否相同。相同：则新的 value 覆盖之前的 value。不相同：则将新的键值对添加到哈希表中
